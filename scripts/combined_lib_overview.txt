Combined overview of lib/*.py
Generated by scripts/combine_lib_files.py

----- FILE: lib/__init__.py -----



----- FILE: lib/coalition.py -----

import numpy as np
from typing import List
from lib.country import Country


class Coalition:
    """Coalition is a collection of cooperating Country instances.

    Arguments:
        members: list (Country) of countries.
    """
    def __init__(self, members: List[Country]):
        self.members = members
        assert all(isinstance(country, Country) for country in self.members)

    @property
    def total_power(self) -> float:
        """Coalition's total global power share.

        Equals the sum of all members' individual powers.
        """
        power = np.sum([country.power for country in self.members])
        assert 0. <= power <= 1., "Coalition's total power must be in [0,1]."
        return power

    @property
    def avg_ideal_G(self) -> float:
        """ Eq. (B.9). Coalition's average ideal geoengineering level."""
        alphas = [country.ideal_geoengineering_level
                  for country in self.members]
        etas = [country.weighted_damage for country in self.members]
        return np.dot(alphas, etas) / np.sum(etas)


----- FILE: lib/country.py -----

class Country:
    """ Represents an individual player in the model.

    Arguments:
        name: Player name ('W', 'T', or 'C' used in the paper).
        base_temp: Preindustrial baseline temperature. T^base in eq. (B.1)
        delta_temp: Climate-induced temperature change. Delta in eq. (B.1).
        ideal_temp: Ideal temperature. T^ideal in eq. (B.3).
        m_damage: Marginal damage term. Param. d in eq. (B.3).
        power: Country's share of global power. Param. gamma in eq. (B.6).
    """

    def __init__(self,
                 name: str,
                 base_temp: float,
                 delta_temp: float,
                 ideal_temp: float,
                 m_damage: float,
                 power: float,
                 ):

        assert m_damage >= 0., "Marginal damage cannot be negative"
        assert 0. <= power <= 1., "Power must be in [0,1]"

        self.name = name
        self.base_temp = base_temp
        self.delta_temp = delta_temp
        self.ideal_temp = ideal_temp
        self.m_damage = m_damage
        self.power = power

    @property
    def climate_change_temp(self) -> float:
        """Eq. (B.1).
        Current temperature with zero geoengineering deployment.
        """
        return self.base_temp + self.delta_temp

    @property
    def ideal_geoengineering_level(self) -> float:
        """Parameter alpha in eq. (B.4)."""
        return self.climate_change_temp - self.ideal_temp

    @property
    def climate_change_damage(self) -> float:
        """ Damages with zero geoengineering deployment.
        Corresponds to parameter K in eq. (B.3).
        """
        return self.m_damage * (self.climate_change_temp-self.ideal_temp) ** 2

    @property
    def weighted_damage(self) -> float:
        """Power-weighter marginal damage.
        Corresponds to parameter eta in eq. (B.7).
        """
        return self.power * self.m_damage

    def damage(self, G: float) -> float:
        """ Climate damages with geoengineering.

        Damages are normalized such that damages with zero SG deployment
        are zero for all countries.

        Arguments:
            G: Current global geoengineering deployment.
        """
        deviation = self.ideal_geoengineering_level - G
        cc_damage = self.climate_change_damage

        return self.m_damage * deviation ** 2 - cc_damage

    def payoff(self, G: float) -> float:
        """ Eq. (B.3). Country's payoff function under geoengineering.

        Arguments:
            G: Current global geoengineering deployment.
        """
        return -self.damage(G)


----- FILE: lib/errors.py -----

from typing import Iterable


class ApprovalCommitteeError(Exception):
    """General Error handler for TransitionProbabilities class."""
    def __init__(self, index: Iterable[str]):
        assert len(index) == 3,\
            "index should be a triplet (proposer, current_state, next_state)"
        self.index = index
    def __str__(self):
        error_msg = (
            "The following transition could not be "
            "handled: Proposer: {}, from state "
            "{} to {}.").format(*self.index)
        return error_msg

----- FILE: lib/mdp.py -----

import numpy as np
import pandas as pd


class MDP:
    """
    General Markov Decision Process placeholder.

    Arguments:
        n_states: Number of possible states in the system.
        transition_probs: n_states * n_states matrix of probabilities.
        discounting: Discounting (and farsightedness) parameter.

    Implementation of this class follows closely the structure in:
    http://aima.cs.berkeley.edu/python/mdp.html and
    https://github.com/akaAlbo/deeprlbootcamp/tree/master/lab1
    """
    def __init__(self,
                 n_states: int,
                 transition_probs: pd.DataFrame,
                 discounting: float):

        self.n_states = n_states
        self.transition_probs = transition_probs
        self.discounting = discounting

    def solve_value_func(self, payoffs: np.ndarray) -> np.ndarray:
        """ Solve the linear system of value functions
        for an individual player.

        Arguments:
            payoffs: A vector of payoffs size n_states for a single country.
        """

        A = np.zeros((self.n_states, self.n_states))
        b = np.zeros(self.n_states)
        P = self.transition_probs

        for state in range(self.n_states):
            for next_state, prob in enumerate(P.iloc[state, :]):
                A[state][next_state] = self.discounting * prob

        A -= np.eye(self.n_states)
        b = -(1-self.discounting) * payoffs
        x = np.linalg.solve(A, b)

        assert np.allclose(np.dot(A, x), b)

        return x


----- FILE: lib/probabilities.py -----

import numpy as np
import pandas as pd
import warnings
from typing import List, Dict
from lib.utils import get_approval_committee, list_members
from lib.errors import ApprovalCommitteeError


class TransitionProbabilities:
    """ Translates the equilibrium strategies of countries into transition
    probabilities between different states.

    Arguments:
        df: A dataframe containing the strategy profiles of all players.
        effectivity: The effectivity correspondence calculated in
                     lib.utils.derive_effectivity().
        players: List (str) of all players in the game.
        states: List (str) of all possible states of the system.
        protocol: Dict with player names as keys and probabilities
                  of being chosen as the proposer as values.
        unanimity_required: A boolean value to indicate whether the
                approval committee needs to be perfectly unanimous for a
                proposition to pass. If False, a simple majority is enough.

    Returns:
        P: Size (n_states, n_states) matrix of transition probabilities of the
           Markov Decision Process. Rows denote current states,
           and columns the possible next states.
        P_proposals: A dictionary with keys determined by triplets
                     (i, x, y). Each value is the probability that player i,
                     IF chosen as proposer, suggests a move from the current
                     state x to a new state y.
        P_approvals: A dictionary with keys determined by triplets
                     (i, x, y). Each value is the probability that the
                     transition proposed by player i, to move from current
                     state x to a new state y, gets accepted by the
                     approval committee.
    """
    def __init__(self,
                 df: pd.DataFrame,
                 effectivity: Dict[tuple, int],
                 players: List[str],
                 states: List[str],
                 protocol: Dict[str, float],
                 unanimity_required: bool):

        self.df = df
        self.effectivity = effectivity
        self.players = players
        self.states = states
        self.protocol = protocol
        self.unanimity_required = unanimity_required

        # Notation: Capital P's stand for probability matrices,
        # lowercase p's for scalar probability values.
        self.P = pd.DataFrame(0., index=states, columns=states)
        self.P_proposals = {}
        self.P_approvals = {}

    def get_probabilities(self):
        if self.unanimity_required:
            return self.transition_probabilities_with_unanimity()
        else:
            return self.transition_probabilities_without_unanimity()

    def safety_checks(self):
        """Check that all computed values are valid probabilities."""
        # All rows in the state transition probability matrix sum up to one.
        assert np.isclose(self.P.sum(axis=1), 1.).all()

        # All probabilities are in [0, 1].
        assert (0. <= self.P.values).all() and (self.P.values <= 1.).all()
        assert all(0. <= val <= 1. for val in self.P_proposals.values())
        assert all(0. <= val <= 1. for val in self.P_approvals.values())

    def read_proposal_prob(self, proposer: str, current_state: str,
                           next_state: str) -> float:
        """Reads an individual proposal entry from the strategy table."""
        probability = self.df.loc[(current_state, 'Proposition', np.nan),
                                  (f'Proposer {proposer}', next_state)]
        return probability

    def read_approval_probs(self, approvers: List[str], proposer: str,
                            current_state: str, next_state: str) -> float:
        """Reads the acceptance probabilities for all members in approvers."""
        probability = self.df.loc[(current_state, 'Acceptance', approvers),
                                  (f'Proposer {proposer}', next_state)]
        return probability

    def empty_approval_committee_warning(self, indx: tuple):
        msg = f"Empty appoval committee for {indx[0]}: {indx[1]} -> {indx[2]}"
        warnings.warn(msg)

    def transition_probabilities_with_unanimity(self):
        """Calculate transition probabilities with a perfectly unanimous
        approval committee.
        """
        
        for proposer in self.players:
            for current_state in self.states:
                for next_state in self.states:

                    indx = (proposer, current_state, next_state)
                    approvers = get_approval_committee(
                        self.effectivity, self.players, *indx)

                    # Probability that the current proposer proposes
                    # next_state while in current_state.
                    p_proposal = self.read_proposal_prob(*indx)
                    self.P_proposals[indx] = p_proposal

                    # If the approval committee is empty, the state transition
                    # is impossible. This should not really happen in the
                    # scenarios considered here. One could add cases where
                    # some transitions are forbidden.
                    if len(approvers) == 0:
                        p_approved = 0.
                        self.empty_approval_committee_warning(indx)

                    # The probability of a transition being approved equals
                    # the probability that all approval committee members
                    # approve unanimously.
                    elif 1 <= len(approvers) <= 2:
                        probs = self.read_approval_probs(approvers, *indx)
                        p_approved = np.prod(probs)
                        # print(*indx, approvers, probs.values, p_approved)
                    else:
                        raise ApprovalCommitteeError(indx)

                    self.P_approvals[indx] = p_approved
                    p_rejected = 1 - p_approved

                    # Probability that proposer is chosen by the protocol, AND
                    # proposes the transition current_state -> next_state.
                    p_proposed = self.protocol[proposer] * p_proposal

                    # If proposed and approved, state changes.
                    self.P.loc[current_state, next_state] +=\
                        p_proposed * p_approved
                    # Otherwise, state remains unchanged.
                    self.P.loc[current_state, current_state] +=\
                        p_proposed * p_rejected

        self.safety_checks()
        return (self.P, self.P_proposals, self.P_approvals)

    def transition_probabilities_without_unanimity(self):
        """Calculate transition probabilities such that the approval is
        required from all new members, but only from the majority of
        existing members.
        """

        for proposer in self.players:
            for current_state in self.states:
                for next_state in self.states:
                    indx = (proposer, current_state, next_state)

                    approvers = get_approval_committee(
                        self.effectivity, self.players, *indx)

                    # Proposal probability:
                    # ---------------------

                    # Probability that proposer proposes next_state while
                    # in current_state.
                    p_proposal = self.read_proposal_prob(*indx)
                    self.P_proposals[indx] = p_proposal

                    # Approval probabilities:
                    # ----------------------

                    # If the approval committee is empty, the state transition
                    # is impossible. This should not really happen in the
                    # scenarios considered here. One could add cases where
                    # some transitions are forbidden.
                    if len(approvers) == 0:
                        p_approved = 0.
                        self.empty_approval_committee_warning(indx)

                    # If the approval committee only has one member, it can
                    # decide alone whether or not to approve the transition
                    # This covers both maintaining status quo, unilateral
                    # breakout, and cases such as W proposing ( ) -> (WC),
                    # where C is the only one who needs to approve.
                    elif len(approvers) == 1:
                        p_approved = self.read_approval_probs(
                            approvers, *indx).values
                        # print(*indx, approvers, p_approved)

                    # For a larger approval committee, we need to consider
                    # the cases where majority approval committee can
                    # validate state transitions.
                    else:
                        assert len(approvers) == 2
                        current_members = list_members(current_state)
                        next_members = list_members(next_state)

                        new_members = [country for country in next_members
                                       if country not in current_members]

                        current_non_proposer_members = [
                            country for country in current_members
                            if country != proposer]

                        new_non_proposer_members = [
                            country for country in new_members
                            if country != proposer]

                        if new_non_proposer_members:
                            # CASE 1:
                            # If there are new non-proposer members joining
                            # the new coalition, and the proposer is not
                            # an existing member, all of the new non-proposer
                            # members approve the transition.
                            # E.g., W proposing ( ) -> (TC) or ( ) -> (WTC)
                            # must be approved by both T and C.

                            # If there are new non-proposer members joining
                            # the new coalition, and the proposer is one of
                            # the existing members AND a member in the new
                            # coalition that forms, all new non-proposer
                            # members must approve the transition.
                            # E.g., W proposing (WC) -> (WT) or (WC) -> (WTC)
                            # must be approved by T but not C.
                            if (proposer not in current_members) or\
                                (proposer in current_members and
                                    proposer in next_members):
                                probs = self.read_approval_probs(
                                    new_non_proposer_members, *indx)
                                p_approved = np.prod(probs)
                                # print(*indx, new_non_proposer_members,
                                #       probs.values, p_approved)

                            # CASE 2:
                            # If there are new non-proposer members joining
                            # the new coalition, and the proposer is one of
                            # the existing members but not a member in the
                            # new coalition that forms, all countries in the
                            # new coalition must approve the transition.
                            # E.g., W proposing (WC) -> (TC) or (WT) -> (TC)
                            # must be approved by both T and C.
                            elif (proposer in current_members) and\
                                 (proposer not in next_members):
                                probs = self.read_approval_probs(
                                    next_members, *indx)
                                p_approved = np.prod(probs)
                                # print(*indx, next_members, probs.values,
                                #       p_approved)
                            else:
                                raise ApprovalCommitteeError(indx)

                        # CASE 3:
                        # If there are no new non-proposer members,
                        # at least one existing member must approve the
                        # proposed transition.
                        # E.g., W proposing (TC) -> ( ) or (TC) -> (WC)
                        # or (WTC) -> ( ) or (WTC) -> (WC) can be approved by
                        # either T or C, or W proposing (WTC)
                        elif not new_non_proposer_members:
                            probs = self.read_approval_probs(
                                    current_non_proposer_members, *indx)
                            p_approved = np.sum(probs) - np.prod(probs)
                            # print(*indx, current_non_proposer_members,
                            #       probs.values, p_approved)
                        else:
                            raise ApprovalCommitteeError(indx)

                    self.P_approvals[indx] = p_approved
                    p_rejected = 1 - p_approved

                    p_proposed = self.protocol[proposer] * p_proposal
                    # If approved, state changes.
                    self.P.loc[current_state, next_state] +=\
                        p_proposed * p_approved
                    # Otherwise, state remains unchanged.
                    self.P.loc[current_state, current_state] +=\
                        p_proposed * p_rejected

        self.safety_checks()
        return (self.P, self.P_proposals, self.P_approvals)


----- FILE: lib/state.py -----

import numpy as np
from typing import List, Dict
from lib.country import Country
from lib.coalition import Coalition


class State:
    """ Encodes the current state of the dynamic coalition game.

    Arguments:
        name: Coalition's name, e.g., '(TC)'.
        coalitions: List of Coalition instances that exist in current state.
        all_countries: List of all Country instances that exist in the game.
        power_rule: Rule to determine the strongest coalition.
        min_power: Minimum required world power share to do geoengineering.
    """
    def __init__(self,
                 name: str,
                 coalitions: List[Coalition],
                 all_countries: List[Country],
                 power_rule: str,
                 min_power: float = None):

        # Safety checks.
        assert all(isinstance(country, Country) for country in all_countries)
        assert all(isinstance(coal, Coalition) for coal in coalitions)

        self.name = name
        self.coalitions = coalitions
        self.all_countries = all_countries
        self.power_rule = power_rule
        self.min_power = min_power
        self.coalition_powers = [coal.total_power for coal in self.coalitions]

        assert np.isclose(np.sum(self.coalition_powers), 1., atol=1e-12),\
            "Coalition powers must sum up to 1."

    @property
    def strongest_coalition(self) -> Coalition:
        """
        Returns the coalition that, according to self.power_rule,
        gets to implement geoengineering.

        Note: we assume that the strongest_coalition is unique.
        """
        if self.power_rule == "power_threshold":
            # Coalition with the highest share of the world power
            # gets to implement geoengineering, if minimum threshold is met.
            def sort_key(coalition): return coalition.total_power
        elif self.power_rule == "weak_governance":
            # Free-driver case: Coalition with the highest average ideal
            # geoengineering level gets to deploy.
            def sort_key(coalition): return coalition.avg_ideal_G
        else:
            msg = ("Incorrect power threshold specification. "
                   "Must be in ['power_threshold', 'weak_governance']")
            raise ValueError(msg)

        sorted_coalitions = sorted(self.coalitions, key=sort_key, reverse=True)
        strongest_coalition = sorted_coalitions[0]
        assert isinstance(strongest_coalition, Coalition)

        return strongest_coalition

    @property
    def geo_deployment_level(self) -> float:
        """Geoengineering deployment chosen by the strongest coalition."""
        winner_power = self.strongest_coalition.total_power
        G = self.strongest_coalition.avg_ideal_G

        if self.power_rule == "power_threshold":
            assert self.min_power is not None, ("Minimum power threshold "
                                                "is not defined.")
            # If minimum power threshold is not exceeded,
            # nobody gets to deploy geoengineering.
            if winner_power < self.min_power:
                G = 0.

            # If in the minimum power threshold scenario the geoengineering
            # deployment is positive, check that there is a unique coalition
            # with the highest share of global power. This is not required in
            # general, but simplifies things in the three-country model
            # considered in this paper.
            else:
                msg = "Several winning coalitions not allowed"
                assert self.coalition_powers.count(winner_power) == 1, msg

                msg = "Incorrect winner assignment"
                assert all(i <= winner_power for i in self.coalition_powers),\
                    msg

        return G

    @property
    def payoffs(self) -> Dict[str, float]:
        """Calculate the payoffs for all countries, given the current
        coalition structure and corresponding geoengineering deployment."""
        G = self.geo_deployment_level

        names = [country.name for country in self.all_countries]
        payoffs = [country.payoff(G) for country in self.all_countries]

        return dict(zip(names, payoffs))


----- FILE: lib/utils.py -----

import numpy as np
import pandas as pd
from typing import List, Dict, Tuple, Any
from lib.state import State


def _escape_latex(s: str) -> str:
    """Escape common LaTeX special characters in a string for safe captions."""
    if not isinstance(s, str):
        return s
    replacements = {
        "\\": "\\textbackslash{}",
        "&": "\\&",
        "%": "\\%",
        "$": "\\$",
        "#": "\\#",
        "_": "\\_",
        "{": "\\{",
        "}": "\\}",
        "~": "\\textasciitilde{}",
        "^": "\\textasciicircum{}",
    }
    for old, new in replacements.items():
        s = s.replace(old, new)
    return s


def get_payoff_matrix(states: List[State], columns: List[str]) -> pd.DataFrame:
    """
    Calculate a payoff matrix for all states and countries in the game.

    Arguments:
        states: A list of State instances (all states considered in the game).
        columns: List (str) of all player names included in the game.
    """
    assert all(isinstance(state, State) for state in states)

    state_names = [state.name for state in states]
    payoffs_df = pd.DataFrame(index=state_names, columns=columns,
                              dtype=np.float64)

    for state in states:
        assert list(state.payoffs.keys()) == columns,\
            "Payoff matrix cols and payoff dict keys do not match!"
        payoffs_df.loc[state.name, :] = state.payoffs

    return payoffs_df


def get_geoengineering_levels(states: List[State]) -> pd.DataFrame:
    """
    Returns the geoengineering deployment level for a given state.

    Arguments:
        states: A list of State instances (all states considered in the game).
    """
    assert all(isinstance(state, State) for state in states)

    G = {}
    for state in states:
        G[state.name] = state.geo_deployment_level

    return pd.DataFrame.from_dict(G, orient='index', columns=["G"])


def list_members(state: str) -> List[str]:
    """ Lists all the member countries of the existing coalition.

    For instance, list_current_members('(WTC)') returns ['W', 'T', 'C'].
    For ( ), returns an empty list.
    """
    no_brackets = list(state[state.find("(")+1:state.find(")")])
    return [char for char in no_brackets if char != " "]


def get_approval_committee(effectivity: Dict[tuple, int], players: List[str],
                           proposer: str, current_state: str,
                           next_state: str) -> List[str]:
    """Returns the list of all players who belong to the approval committee
    when proposer proposes the transition (current_state) -> (next_state).

    Arguments:
        effectivity: The effectivity correspondence, from derive_effectivity().
        players: The list (string) of all countries in the game.
        proposer: The current proposer country.
        current_state: Current coalition structure of the game.
        next_state: The next coalition structure suggested by proposer.
    """

    comm = [player for player in players
            if effectivity[(proposer, current_state, next_state, player)] == 1]

    return comm


def derive_effectivity(df: pd.DataFrame, players: List[str],
                       states: List[str]) -> Dict[tuple, int]:
    """ Defines the effectivity correspondence from the strategy profiles.

    For each possible proposer, every possible state transition, and
    every possible other player as a responder, the effectivity matrix
    has a value of 1 if that responder is in the approval committee, and
    0 otherwise.

    Note that the set of responders is the full set of players. That is, 
    we also consider cases where a proposer can "propose" a transition to
    itself. This is important, as in most settings countries might be able
    to unilaterally exit their current coalition structure.

    Arguments:
        df: A DataFrame instance containing the strategies of all players.
        players: A list (str) of all the players in the game.
        states: A list (str) of all the considered states of the system.

    Returns:
        effectivity: a dictionary with keys being the 4-tuples
                     (proposer, current_state, next_state, responder), and
                     the value being a boolean 0 or 1. Each entry tells
                     whether the responder is a member of the approval
                     committee, when the proposer suggests a transition from
                     the current_state to next_state.
    """

    effectivity = {}

    for proposer in players:
        for current_state in states:
            for next_state in states:
                for responder in players:

                    # If the corresponding 'acceptance' cell is not empty,
                    # the player is a member of the approval committee.
                    resp_val = df.loc[(current_state, 'Acceptance', responder),
                                      (f'Proposer {proposer}', next_state)]
                    is_member = int(~np.isnan(resp_val))

                    idx = (proposer, current_state, next_state, responder)
                    effectivity[idx] = is_member

                # Trivially, the proposer must approve the transition,
                # and is therefore included in the effectivity correspondence.
                # However, for convenience, we only include the proposer
                # explicitly in the strategy table when the proposer is the
                # only approval committee member, and thus can approve
                # the proposed transition without consulting others.

                # For every possible proposer, it is always possible to
                # maintain the status quo without the approval of others.
                # Therefore, for such a transition, check that the current
                # proposer is the only member in the effectivity
                # correspondence. Similarly, any country is allowed to
                # walk out of its existing coalition.
                if current_state == next_state or is_unilateral_breakout(
                                    proposer, current_state, next_state):

                    committee = get_approval_committee(effectivity, players,
                                                       proposer, current_state,
                                                       next_state)
                    assert [proposer] == committee

    return effectivity


def is_unilateral_breakout(proposer: str, current_state: str,
                           next_state: str) -> bool:
    """Check if the current transition corresponds to the proposer alone
    walking out of an existing coalition. Such a move is always allowed,
    and needs not be approved by any other players.

    Arguments:
        proposer: Name of the current proposer. E.g., 'T'.
        current_state: Current coalition structure. E.g., '(WTC)'.
        next_state: Proposed next coalition structure. E.g., '(WC)'.

    For instance: 'T' proposing '(WTC)' -> '(WC)' returns True.
    """

    current_members = list_members(current_state)
    next_members = list_members(next_state)

    # If breakout from grand coalition.
    if len(current_members) == 3 and len(next_members) == 2:
        if proposer in current_members and proposer not in next_members:
            return True

    # If breakout from a coalition of 2 players to all singletons.
    elif len(current_members) == 2 and len(next_members) == 0:
        if proposer in current_members:
            return True
    else:
        return False


def verify_proposals(players: List[str], states: List[str],
                     P_proposals: Dict[tuple, float],
                     P_approvals: Dict[tuple, float],
                     V: pd.DataFrame) -> Tuple[bool, str]:
    """Checks that the proposal strategies of all players constitute a
    valid equilibrium, as specified in Condition 1 in section A.5.

    Arguments:
        players: A list of all countries in the game.
        states: A list of all possible states in the system.
        P_proposals: A dictionary with keys determined by triplets
                     (i, x, y). Each value is the probability that player i,
                     IF chosen as proposer, suggests a move from the current
                     state x to a new state y.
        P_approvals: A dictionary with keys determined by triplets
                     (i, x, y). Each value is the probability that the
                     transition proposed by player i, to move from current
                     state x to a new state y, gets accepted by the
                     approval committee.
        V: A dataframe containing the long-run expected payoff for all
           players in all states.
    """

    for proposer in players:
        for current_state in states:

            # All next states for which the proposer attaches
            # a positive proposition probability while in current_state.
            pos_prob_next_states = []

            # Expectation of the proposition value:
            # E = p_accepted * V_next + p_rejected * V_current
            expected_values = {}

            for next_state in states:

                p_proposed = P_proposals[(proposer, current_state,
                                         next_state)]

                if p_proposed > 0.:
                    pos_prob_next_states.append(next_state)

                # Probability that the approval committee accepts.
                p_approved = P_approvals[(proposer, current_state,
                                         next_state)]
                p_rejected = 1 - p_approved

                V_current = V.loc[current_state, proposer]
                V_next = V.loc[next_state, proposer]
                expected_values[next_state] =\
                    p_approved * V_next + p_rejected * V_current

            # Next state(s) that give the highest possible expected
            # long-run payoff.
            argmaxes = [key for key, val in expected_values.items()
                        if np.isclose(val, max(expected_values.values()),
                        atol=1e-12)]

            try:
                # Any state with a positive proposal probability must be one
                # of the best alternatives.
                assert set(pos_prob_next_states).issubset(argmaxes)
            except AssertionError:
                error_msg = (
                         f"Proposal strategy error with player {proposer}! "
                         f"In state {current_state}, positive probability "
                         f"on state(s) {pos_prob_next_states}, but the argmax "
                         f"states are: {argmaxes}. \n"
                         f"The value functions V are: \n"
                         f"{V}"
                         )
                return False, error_msg

    return True, "Test passed."


def verify_approvals(players: List[str], states: List[str],
                     effectivity: Dict[tuple, int], V: pd.DataFrame,
                     strategy_df: pd.DataFrame) -> Tuple[bool, str]:
    """Checks that the approval strategies of all players constitute a
    valid equilibrium, as specified in Condition 2 in section A.5.

    Arguments:
        players: A list of all countries in the game.
        states: A list of all possible states in the system.
        effectivity: The effectivity correspondence, from derive_effectivity().
        V: A dataframe containing the long-run expected payoff for all
           players in all states.
        strategy_df: A dataframe containing the strategies of all players.
    """

    for proposer in players:
        for current_state in states:
            for next_state in states:

                # Approval committee for this transition.
                approvers = get_approval_committee(
                    effectivity, players, proposer, current_state, next_state)

                for approver in approvers:
                    V_current = V.loc[current_state, approver]
                    V_next = V.loc[next_state, approver]
                    p_approve = strategy_df.loc[
                                    (current_state, 'Acceptance', approver),
                                    (f'Proposer {proposer}', next_state)]

                    if np.isclose(V_next, V_current, atol=1e-12):
                        passed = (0. <= p_approve <= 1.)
                    elif V_next > V_current:
                        passed = (p_approve == 1.)
                    elif V_next < V_current:
                        passed = (p_approve == 0.)
                    else:
                        msg = 'Unknown error during approval consistency check'
                        raise ValueError(msg)

                    if not passed:
                        error_msg = (
                            f"Approval strategy error with player {approver}! "
                            f"When player {proposer} proposes the transition "
                            f"{current_state} -> {next_state}, the values are "
                            f"V(current) = {V_current:.5f} "
                            f"and V(next) = {V_next:.5f}, "
                            f"but approval probability is {p_approve}."
                            )
                        return False, error_msg

    return True, "Test passed."


def verify_equilibrium(result: Dict[str, Any]):
    """Checks that the experiment results and strategy profiles are a
    valid equilibrium.

    Arguments:
        results: A dictionary from main.run_experiment().
    """

    proposals_ok = verify_proposals(players=result["players"],
                                    states=result["state_names"],
                                    P_proposals=result["P_proposals"],
                                    P_approvals=result["P_approvals"],
                                    V=result["V"])

    approvals_ok = verify_approvals(players=result["players"],
                                    states=result["state_names"],
                                    effectivity=result["effectivity"],
                                    V=result["V"],
                                    strategy_df=result["strategy_df"])

    if proposals_ok[0] and approvals_ok[0]:
        return True, "All tests passed."
    else:
        messages = [check[1] for check in [proposals_ok, approvals_ok]
                    if not check[0]]

        return False, '\n'.join(messages)


def write_latex_tables(result: Dict[str, Any], variables: List[str],
                       results_path: str = "./results",
                       float_format: str = "%.5f") -> None:
    """Writes experiment results as .tex tables.

    Arguments:
        results: A dictionary from main.run_experiment().
        variables: A list of items in results.keys() to store.
        results_path: Folder to store the .tex files in.
        float_format: How many digits to include in the .tex tables.
    """

    experiment = result['experiment_name']
    for variable in variables:

        path = f"{results_path}/{variable}_{experiment}.tex"
        raw_caption = f"{experiment}: {variable}"
        safe_caption = _escape_latex(raw_caption)
        result[variable].to_latex(buf=path, float_format=float_format,
                      caption=safe_caption)


